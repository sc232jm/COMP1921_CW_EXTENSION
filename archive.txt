#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <time.h>

int height;
int width;

typedef struct cell {
    int key;
    int xPos;
    int yPos;
    char type;
    int visited;
    int walls[4];
} cell;

typedef struct edge {
    int destKey;
    int weight;
} edge;

typedef struct node {
    int key;
    int xPos;
    int yPos;
    int edgeCount;
    edge edges[4];
} node;

typedef struct queue {
    int arrSize;
    int head;
    int tail;
    node *arr[1024];
} queue;

queue nodeStack;
cell **grid;
node *graph;

void enqueue(node *n) {
    nodeStack.arr[nodeStack.tail] = n;
    nodeStack.tail++;
    nodeStack.arrSize++;
}

void dequeue() {
    nodeStack.head++;
    nodeStack.arrSize--;
}

void addNeighbour(int key, int destKey, int weight) {
    for(int i = 0; i < height*width; ++i) {
        if (graph[i].key == key) {
            edge e;
            e.destKey = destKey;
            e.weight = weight;

            graph[i].edges[graph[i].edgeCount] = e; 
            graph[i].edgeCount++;
        }
    }
}

void generateGraph() {
    for (int i = 0; i < height; ++i) {
        for (int j = 0; j < width; j ++ ) {
            int key = grid[i][j].key;
            int randWeight = (rand() % 5);
            if (i - 1 >= 0) {
                addNeighbour(key, grid[i-1][j].key, randWeight);
            }
            
            if (j - 1 >= 0) {
                addNeighbour(key, grid[i][j-1].key, randWeight);
            }

            if (i + 1 < height) {
                addNeighbour(key, grid[i+1][j].key, randWeight);
            }
            
            if (j + 1 < width) {
                addNeighbour(key, grid[i][j+1].key, randWeight);
            }
        }
            
    }
};

void generateGrid() {
    int count = 0;
    grid = malloc(height * sizeof(cell *));
    
    for (int i = 0; i < height; ++i) {
        grid[i] = malloc(width * sizeof(cell));
        
        for (int j = 0; j < width; j++) {
            cell c;
            c.key = count;
            c.xPos = i;
            c.yPos = j;
            c.type = '#';
            c.visited = 0;
            
            for (int i = 0; i<4; ++i) {
                c.walls[i] = 1;
            }
            grid[i][j] = c;
      

            node n;
            n.key = count;
            n.xPos = i;
            n.yPos = j;
            n.edgeCount = 0;
            graph[count] = n;

            ++count;
        }
    }
}

node* selectRand(int x, int y) {
    node selectedNode = graph[grid[x][y].key];
    int freeEdges = 0;
    node edgeList[4];

    for (int i = 0; i<selectedNode.edgeCount; ++i) {
        node targetNode = graph[selectedNode.edges[i].destKey];
        if (grid[targetNode.xPos][targetNode.yPos].visited == 0) { edgeList[freeEdges] = targetNode; freeEdges++; }
    };
    if (freeEdges == 0) { return NULL; }
    int selection = (rand() % freeEdges);
    return &graph[edgeList[selection].key];
};

void flagWalls(node *targetNode, node *selectedNode) {
    int deltaX = selectedNode->xPos - targetNode->xPos;
    int deltaY = selectedNode->yPos - targetNode->yPos;

    cell *targetCell = &grid[targetNode->xPos][targetNode->yPos];

    switch(deltaX < 0 ? 0 : deltaY < 0 ? 2 : deltaX > 0 ? 1 : 3) {
        case 0:
            targetCell->walls[0] = 0;
            break;
        case 1:
            targetCell->walls[1] = 0;
            break;
        case 2:
            targetCell->walls[2] = 0;
            break;
        case 3:
            targetCell->walls[3] = 0;
            break;
    }

    // node selectedNode = graph[grid[x][y].key];
    //  for (int i = 0; i<selectedNode.edgeCount; ++i) {
    //     node targetNode = graph[selectedNode.edges[i].destKey];
    //     grid[targetNode.xPos][targetNode.yPos].visited = 1;
    // };
}

void pathGeneration() {
    int randX = 1 + (rand() % (height-1));
    int randY = 1 + (rand() % (width-1));

    enqueue(&graph[grid[randX][randY].key]);
    grid[randX][randY].visited = 1;
    grid[randX][randY].type = 'S';
    
    while(nodeStack.arrSize > 0) {
        node *selected = NULL;
        selected = selectRand(nodeStack.arr[nodeStack.head]->xPos, nodeStack.arr[nodeStack.head]->yPos);
        if (selected == NULL) {
            dequeue();
        } else {
            grid[selected->xPos][selected->yPos].visited = 1;
            if (grid[nodeStack.arr[nodeStack.head]->xPos][nodeStack.arr[nodeStack.head]->yPos].type != 'S') {
                flagWalls(nodeStack.arr[nodeStack.head], selected);
                // grid[nodeStack.arr[nodeStack.head]->xPos][nodeStack.arr[nodeStack.head]->yPos].walls[0 ];
            }

            enqueue(&graph[selected->key]);
        }
    }

    grid[nodeStack.arr[nodeStack.head-1]->xPos][nodeStack.arr[nodeStack.head-1]->yPos].type = 'E';
};

void printCell(int x, int y) {

};

int main(int argc, char *argv[]) {
    height = atoi(argv[1])/2;
    width = atoi(argv[2])/2;
    if(argc == 4) {
        srand(atoi(argv[3]));
    } else {
        srand(time(NULL));
    }

    graph = malloc(height*width*sizeof(node));

    generateGrid();
    generateGraph();
    pathGeneration();

    for (int i = 0; i < height; ++i) {
        for (int j = 0; j < width; ++j) {
            printf("%c ", grid[i][j].walls[0] ? '#' : ' ');
        }
        for (int j = 0; j < width; ++j) {
            printf("%c %c %c ", grid[i][j].walls[3] ? '#' : ' ', grid[i][j].type, grid[i][j].walls[2] ? '#' : ' ');
        }
        for (int j = 0; j < width; ++j) {
            printf("%c ", grid[i][j].walls[1] ? '#' : ' ');
        }
        printf("\n");
    }

    free(grid);
}